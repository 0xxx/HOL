(* generated by Lem from miniML.lem *)
open bossLib Theory Parse res_quanTheory
open finite_mapTheory listTheory pairTheory pred_setTheory
open set_relationTheory sortingTheory stringTheory wordsTheory

val _ = new_theory "MiniML"

(* By Scott Owens, University of Cambridge, Copyright 2011
 *
 * Miniml is my idea of the simplest ML-like language that remains convenient to
 * program in.  It is purely functional (no refs or exceptions), has no modules,
 * no type abbreviations, or record types.  It does have mutually recursive
 * datatypes (at the top-level only) and functions, as well as higher-order
 * functions.  It also supports pattern matching for nested patterns (which can
 * fail due to non-exhaustive patterns).  Only booleans and number types are
 * built-in.  Syntactic sugar is generally omitted.
 *
 * In some ways it makes more sense to write these kind of semantics in Ott (to
 * get a presentation that looks like ML concrete-syntax-wise, and that has the
 * usual syntax for type systems and operational semantics, i.e., with |- and
 * horizontal lines).  Here in Lem, everything looks like abstract syntax;
 * however, unlike Ott, we get good support for functions, and not just
 * relations.
 * 
 * The small-step operational semantics is based on the CEK machine.  The type
 * system is typical, but it doesn't yet support polymorphism. *)

(*val all_distinct : forall 'a. 'a list -> bool*)

(* Environments *)
val _ = type_abbrev((*  ('a,'b) *) "env" , ``: ('a#'b) list``);

(*val emp : forall 'a 'b. ('a,'b) env*)
val _ = Define `
 emp = []`;


(*val lookup : forall 'a 'b. 'a -> ('a,'b) env -> 'b option*)
 val lookup_defn = Hol_defn "lookup" `
 
(lookup n [] = NONE)
/\
(lookup n ((n',v)::e) =
  if n' = n then
    SOME v
  else
    lookup n e)`;

val _ = Defn.save_defn lookup_defn; 

(*val bind : forall 'a 'b. 'a -> 'b -> ('a,'b) env -> ('a,'b) env*)
val _ = Define `
 (bind n v e = (n,v)::e)`;


(*val merge : forall 'a 'b. ('a,'b) env -> ('a,'b) env -> ('a,'b) env*)
val _ = Define `
 (merge e1 e2 = e1 ++ e2)`;


(* Literal constants *)
val _ = Hol_datatype `
 lit = 
    Num of num
  | Bool of bool`;


(* Built-in binary operations *)
val _ = Hol_datatype `
 op =
    Opn of (num -> num -> num)
  | Opb of (num -> num -> bool)`;


(* Built-in logical operations *)
val _ = Hol_datatype `
 log = 
    And
  | Or`;
 

(* Variable names *)
val _ = type_abbrev( "varN" , ``: string``);
(* Constructor names (from datatype definitions) *)
val _ = type_abbrev( "conN" , ``: string``);
(* Type names *)
val _ = type_abbrev( "typeN" , ``: string``);
(* Type variable names *)
val _ = type_abbrev( "tvarN" , ``: string``);

(* Types
 * 0-ary type applications represent unparameterised types (e.g., num or string)
 *)
val _ = Hol_datatype `
 t = 
    Tvar of tvarN
  | Tapp of t list => typeN
  | Tfn of t => t
  | Tnum
  | Tbool`;


(*val type_subst : (tvarN,t) env -> t -> t*)
 val type_subst_defn = Hol_defn "type_subst" `

(type_subst s (Tvar tv) =
  (case lookup tv s of
       NONE -> (Tvar tv)
    || SOME(t) -> t
  )) 
/\
(type_subst s (Tapp ts tn) =
  Tapp (MAP (type_subst s) ts) tn)
/\
(type_subst s (Tfn t1 t2) =
  Tfn (type_subst s t1) (type_subst s t2))
/\
(type_subst s Tnum = Tnum)
/\
(type_subst s Tbool = Tbool)`;

val _ = Defn.save_defn type_subst_defn;

(* Patterns *)
val _ = Hol_datatype `
 pat =
    Pvar of varN
  | Plit of lit
  (* Constructor applications *)
  | Pcon of conN => pat list`;


(* Expressions *)
val _ = Hol_datatype `
 exp = 
    Val of v
  (* Constructor application *)
  | Con of conN => exp list
  | Var of varN
  | Fun of varN => exp
  | App of exp => exp
  (* Logical operations (and, or) *)
  | Log of log => exp => exp
  (* Builtin binary operations on numbers *)
  | Op of op => exp => exp
  | If of exp => exp => exp
  (* Pattern matching *)
  | Mat of exp => (pat # exp) list
  | Let of varN => exp => exp
  (* Local definition of (potentially) mutually recursive functions The first
   * varN is the function's name, and the second varN is its parameter *)
  | Letrec of (varN # varN # exp) list => exp

(* Value forms *)
; v =
    Lit of lit
  (* Constructor application *)
  | Conv of conN => v list
  (* Function closures
     The environment is used for the free variables in the function *)
  | Closure of (varN, v) env => varN => exp
  (* Function closure for recursive functions 
     See Closure and Letrec above
     The last variable name indicates which function from the mutually recursive
     bundle this closure value represents *) 
  | Recclosure of (varN, v) env => (varN # varN # exp) list => varN`;


(* Environments *)
val _ = type_abbrev( "envE" , ``: (varN, v) env``);

(* Declarations *)
val _ = Hol_datatype `
 dec = 
  (* Top-level bindings
     The pattern allows several names to be bound at once *)
    Dlet of pat => exp
  (* Mutually recursive function definition *)
  | Dletrec of (varN # varN # exp) list  
  (* Type definition
     Defines several types, each of which has several named variants, which can
     in turn have several arguments *)
  | Dtype of (tvarN list # typeN # (conN # t list) list) list`;


val _ = type_abbrev( "decs" , ``: dec list``);

(* Maps each constructor to its arity and the set of all constructors of that
 * type *) 
val _ = type_abbrev( "envC" , ``: (conN, num # conN set) env``);

(* Evaluation contexts 
 * The hole is denoted by the unit type *)
val _ = Hol_datatype `
 ctxt = 
    Capp1 of unit => exp
  (* Function application *)
  | Capp2 of envE => varN => exp => unit
  (* Application of a recursive function *)
  | Capp3 of envE => (varN # varN # exp) list => varN => unit
  | Clog of log => unit => exp
  | Cop1 of op => unit => exp
  | Cop2 of op => v => unit
  | Cif of unit => exp => exp
  | Cmat of unit => (pat # exp) list
  | Clet of varN => unit => exp
  (* Evaluating a constructor's arguments
   * The v list should be in reverse order. *)
  | Ccon of conN => v list => unit => exp list`;


(*val lit_same_type : lit -> lit -> bool*)
val _ = Define `
 (lit_same_type l1 l2 =
  (case (l1,l2) of
       (Num _, Num _) -> T
    || (Bool _, Bool _) -> T
    || _ -> F
  ))`;


val _ = Hol_datatype `
 match_result =
    No_match
  | Match_type_error
  | Match of envE`;


(* A big-step pattern matcher.  If the value
 * matches the pattern, return an environment with the pattern variables bound
 * to the corresponding sub-terms of the value; this environment extends the
 * environment given as an argument.  No_match is returned when there is no
 * match, but any constructors encountered in determining the match failure are
 * applied to the correct number of arguments, and constructors in
 * corresponding positions in the pattern and value come from the same type.
 * Match_type_error is returned when one of these conditions is violated *)

(*val pmatch : envC -> pat -> v -> envE -> match_result*)
 val pmatch_defn = Hol_defn "pmatch" `
 
(pmatch envC (Pvar n) v' env = Match (bind n v' env))
/\
(pmatch envC (Plit l) (Lit l') env =
  if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error)
/\
(pmatch envC (Pcon n ps) (Conv n' vs) env =
  (case (lookup n envC, lookup n' envC) of
       (SOME (l, ns), SOME (l', ns')) ->
        if n IN ns' /\ n' IN ns /\ (LENGTH ps = l) /\ (LENGTH vs = l')
        then
          if n = n' then
            pmatch_list envC ps vs env
          else
            No_match
        else
          Match_type_error
    || (_, _) -> Match_type_error
  ))
/\
(pmatch envC _ _ env = Match_type_error)
/\
(pmatch_list envC [] [] env = Match env)
/\
(pmatch_list envC (p::ps) (v::vs) env =
  (case pmatch envC p v env of
       No_match -> No_match
    || Match_type_error -> Match_type_error
    || Match env' -> pmatch_list envC ps vs env'
  ))
/\
(pmatch_list envC _ _ env = Match_type_error)`;

val _ = Defn.save_defn pmatch_defn;

(* State for CEK-style expression evaluation
 * - constructor data
 * - the environment for the free variables of the current expression 
 * - the current expression to evaluate
 * - the context stack (continuation) of what to do once the current expression
 *   is finished.  Each entry has an environment for it's free variables *)
val _ = type_abbrev( "state" , ``: envC # envE # exp # (ctxt # envE) list``);

val _ = Hol_datatype `
(*  'a *) step_result =
    State of 'a
  | Stuck
  | BindError
  | TypeError`;


(* The semantics are deterministic, and presented functionally instead of
 * relationally for proof rather that readability; the steps are very small: we
 * push individual frames onto the context stack instead of finding a redex in a
 * single step *)

(*val push : envC -> envE -> exp -> ctxt -> (ctxt * envE) list -> state step_result*)
val _ = Define `
 (push envC env e c' cs = State (envC, env, e, (c',env)::cs))`;


(*val return : envC -> envE -> v -> (ctxt * envE) list -> state step_result*)
val _ = Define `
 (return envC env v c = State (envC, env, Val v, c))`;


(* Bind each function of a mutually recursive set of functions to its closure *)
(*val build_rec_env : (varN * varN * exp) list -> envE -> envE*)
 val build_rec_env_defn = Hol_defn "build_rec_env" `
 (build_rec_env funs env =
  FOLDR 
    (\ (f,x,e) env' . bind f (Recclosure env funs f) env') 
    env 
    funs)`;

val _ = Defn.save_defn build_rec_env_defn;

(* Lookup in the list of mutually recursive functions *)
(*val find_recfun : varN -> (varN * varN * exp) list -> (varN * exp)option*)
 val find_recfun_defn = Hol_defn "find_recfun" `
 (find_recfun n funs =
  (case funs of
       [] -> NONE
    || (f,x,e) :: funs -> 
        if f = n then 
          SOME (x,e) 
        else 
          find_recfun n funs
  ))`;

val _ = Defn.save_defn find_recfun_defn;

(* apply a context to a value *)
(*val continue : envC -> v -> (ctxt * envE) list -> state step_result*)
val _ = Define `
 (continue envC v cs =
  (case cs of
       [] -> Stuck
    || (Capp1 () e, env) :: c -> 
        (case v of
             Closure env' n e' -> push envC env e (Capp2 env' n e' ()) c
          || Recclosure env' funs n -> push envC env e (Capp3 env' funs n ()) c
          || _ -> TypeError
        )
    || (Capp2 env' n e (), env) :: c -> State (envC, bind n v env', e, c)
    || (Capp3 env' funs n (), env) :: c -> 
        (case find_recfun n funs of
             SOME (n,e) -> State (envC, bind n v (build_rec_env funs env'), e, c)
          || _ -> TypeError
        )
    || (Clog op () e, env) :: c ->
        if ((v = Lit (Bool T)) /\ (op = And)) \/ 
           ((v = Lit (Bool F)) /\ (op = Or)) then
          State (envC, env, e, c)
        else if (v = Lit (Bool F)) /\ (op = And) then
          return envC env (Lit (Bool F)) c
        else if (v = Lit (Bool T)) /\ (op = Or) then
          return envC env (Lit (Bool T)) c
        else 
          TypeError
    || (Cop1 op () e, env) :: c ->
        push envC env e (Cop2 op v ()) c
    || (Cop2 op v' (), env) :: c ->
        (case (v', v, op) of
             (Lit (Num n'), Lit (Num n), Opn f) ->
              return envC env (Lit (Num (f n' n))) c 
          || (Lit (Num n'), Lit (Num n), Opb f) ->
              return envC env (Lit (Bool (f n' n))) c
          || _ ->
              TypeError
        )
    || (Cif () e1 e2, env) :: c ->
        if v = Lit (Bool T) then
          State (envC, env, e1, c)
        else if v = Lit (Bool F) then
          State (envC, env, e2, c)
        else 
          TypeError
    || (Cmat () [], env) :: c ->
        BindError
    || (Cmat () ((p,e)::pes), env) :: c ->
        (case pmatch envC p v env of
             Match_type_error -> TypeError
          || No_match -> push envC env (Val v) (Cmat () pes) c
          || Match env' -> State (envC, env', e, c)
        )
    || (Clet n () e, env) :: c ->
        State (envC, bind n v env, e, c) 
    || (Ccon n vs () [], env) :: c ->
        return envC env (Conv n (REVERSE (v::vs))) c
    || (Ccon n vs () (e::es), env) :: c ->
        push envC env e (Ccon n (v::vs) () es) c
  ))`;


(* The single step expression evaluator.  Returns Stuck if there is nothing to
 * do, but no type error.  Returns Type_error on encountering free variables,
 * mis-applied (or non-existent) constructors, and when the wrong kind of value
 * if given to a primitive.  Returns BindError when no pattern in a match
 * matches the value.  Otherwise it returns the next state *)

(*val e_step : state -> state step_result*)
val _ = Define `
 (e_step (envC, env, e, c) =
  (case e of
       Val v  -> 
	continue envC v c
    || Con n es -> 
        (case lookup n envC of
             NONE -> TypeError
          || SOME (l,_) -> 
	      if l = LENGTH es then
                (case es of
                     [] -> return envC env (Conv n []) c
                  || e::es ->
                      push envC env e (Ccon n [] () es) c
                )
              else
                TypeError
        )
    || Var n ->
        (case lookup n env of
             NONE -> TypeError
          || SOME v -> State (envC, env, Val v, c)
        )
    || Fun n e -> State (envC, env, Val (Closure env n e), c)
    || App e1 e2 -> push envC env e1 (Capp1 () e2) c 
    || Log l e1 e2 -> push envC env e1 (Clog l () e2) c
    || Op op e1 e2 -> push envC env e1 (Cop1 op () e2) c
    || If e1 e2 e3 -> push envC env e1 (Cif () e2 e3) c
    || Mat e pes -> push envC env e (Cmat () pes) c
    || Let n e1 e2 -> push envC env e1 (Clet n () e2) c
    || Letrec funs e ->
        if ~ (ALL_DISTINCT (MAP (\ (x,y,z) . x) funs)) then
          TypeError
        else
          State (envC, build_rec_env funs env, e, c)
  ))`;
 

(* Add the given type definition to the given constructor environment *)
(*val build_tdefs : 
  (tvarN list * typeN * (conN * t list) list) list -> envC -> envC*)
val _ = Define `
 (build_tdefs tds envC =
  FOLDR 
    (\ (tvs, tn, condefs) envC .
       FOLDR 
         (\ (conN, ts) envC .
            bind conN (LENGTH ts, 
                       {cn | cn,ts | ( MEM(cn,ts) condefs) /\ T}) envC) 
         envC 
         condefs) 
    envC 
    tds)`;
 

(* Checks that no constructor is defined twice *)
(*val check_dup_ctors : 
    (tvarN list * typeN * (conN * t list) list) list -> envC -> bool*)
val _ = Define `
 (check_dup_ctors tds envC =
  (! ((tvs, tn, condefs) :: LIST_TO_SET tds) ((n, ts) :: LIST_TO_SET condefs).
   lookup n envC = NONE) /\
  ALL_DISTINCT 
    (let x2 = [] in FOLDR  (\(tvs, tn, condefs) x2 . FOLDR  (\(n, ts) x2 . if T then n:: x2 else x2)  x2  condefs)  x2  tds))`;


(* Whole program state
 * - constructor data
 * - values bound be previous definitions
 * - remaining definitions
 * - current state for evaluating the current definition *)
val _ = type_abbrev( "d_state" , ``: envC # envE # decs # (pat # state)option``);

(*val d_step : d_state -> d_state step_result*)
val _ = Define `
 (d_step (envC, env, ds, st) =
  (case st of
       SOME (p, (envC, env', Val v, c)) -> 
        (case pmatch envC p v env of
             Match env' -> State (envC, env', ds, NONE)
          || No_match -> BindError
          || Match_type_error -> TypeError
        )
    || SOME (p, (envC, env', e, c)) -> 
        (case e_step (envC, env', e, c) of
             Stuck -> Stuck
          || TypeError -> TypeError
          || BindError -> BindError
          || State st -> State (envC, env, ds, SOME (p, st))
        )
    || NONE ->
        (case ds of
             [] -> Stuck
          || (Dlet p e) :: ds ->
              State (envC, env, ds, SOME (p, (envC, env, e, [])))
          || (Dletrec funs) :: ds ->
              State (envC, build_rec_env funs env, ds, NONE)
          || (Dtype tds) :: ds ->
              if check_dup_ctors tds envC then
                TypeError
              else 
                State (build_tdefs tds envC, env, ds, NONE)
      )
  ))`;


(* ------------------------ Big step semantics -------------------------- *)

(* Berror should be true for a BindError and false for a TypeError *)
val _ = Hol_datatype `
(*  'a *) big_step_result =
    Bvalue of 'a
  | Berror of bool`;


(*val evaluate : envC -> envE -> exp -> v big_step_result -> bool*)
(*val evaluate_list : envC -> envE -> exp list -> v list big_step_result -> bool*)
(*val evaluate_match : envC -> envE -> v -> (pat * exp) list -> v big_step_result -> bool*)

val _ = Hol_reln `

(! cenv env v.
T
==>
evaluate cenv env (Val v) (Bvalue v))

/\

(! cenv env cn es vs ns.
(lookup cn cenv = SOME (LENGTH es,ns)) /\
evaluate_list cenv env es (Bvalue vs)
==>
evaluate cenv env (Con cn es) (Bvalue (Conv cn vs)))

/\

(! cenv env cn es l ns.
(lookup cn cenv = NONE) \/ 
((lookup cn cenv = SOME (l,ns)) /\ l <> LENGTH es)
==>
evaluate cenv env (Con cn es) (Berror F))

/\

(! cenv env cn es err ns.
(lookup cn cenv = SOME (LENGTH es,ns)) /\
evaluate_list cenv env es (Berror err)
==>
evaluate cenv env (Con cn es) (Berror err))

/\

(! cenv env n v.
(lookup n env = SOME v)
==>
evaluate cenv env (Var n) (Bvalue v))

/\

(! cenv env n.
(lookup n env = NONE)
==>
evaluate cenv env (Var n) (Berror F))

/\

(! cenv env n e.
T
==>
evaluate cenv env (Fun n e) (Bvalue (Closure env n e)))

/\

(! cenv env e1 e2 env' n e v bv.
evaluate cenv env e1 (Bvalue (Closure env' n e)) /\
evaluate cenv env e2 (Bvalue v) /\
evaluate cenv (bind n v env') e bv
==>
evaluate cenv env (App e1 e2) bv)

/\

(! cenv env e1 e2 env' funs fn v bv n e.
evaluate cenv env e1 (Bvalue (Recclosure env' funs fn)) /\
evaluate cenv env e2 (Bvalue v) /\
(find_recfun fn funs = SOME (n,e)) /\
evaluate cenv (bind n v (build_rec_env funs env')) e bv
==>
evaluate cenv env (App e1 e2) bv)

/\

(! cenv env e1 e2 err.
evaluate cenv env e1 (Berror err)
==>
evaluate cenv env (App e1 e2) (Berror err))

/\

(! cenv env e1 e2 v l cn vs.
evaluate cenv env e1 (Bvalue v) /\
((v = Lit l) \/ (v = Conv cn vs))
==>
evaluate cenv env (App e1 e2) (Berror F))

/\

(! cenv env e1 e2 v env' funs fn n e err.
evaluate cenv env e1 (Bvalue v) /\
((v = Closure env' n e) \/ (v = Recclosure env' funs fn)) /\
evaluate cenv env e2 (Berror err)
==>
evaluate cenv env (App e1 e2) (Berror err))

/\

(! cenv env e1 e2 env' funs fn v.
evaluate cenv env e1 (Bvalue (Recclosure env' funs fn)) /\
evaluate cenv env e2 (Bvalue v) /\
(find_recfun fn funs = NONE) 
==>
evaluate cenv env (App e1 e2) (Berror F))


/\

(! cenv env e1 e2 bv.
evaluate cenv env e1 (Bvalue (Lit (Bool T))) /\
evaluate cenv env e2 bv
==>
evaluate cenv env (Log And e1 e2) bv)

/\

(! cenv env e1 e2 bv.
evaluate cenv env e1 bv /\
~ (bv = Bvalue (Lit (Bool T)))
==>
evaluate cenv env (Log And e1 e2) bv)

/\

(! cenv env e1 e2 bv.
evaluate cenv env e1 (Bvalue (Lit (Bool F))) /\
evaluate cenv env e2 bv
==>
evaluate cenv env (Log Or e1 e2) bv)

/\

(! cenv env e1 e2 bv.
evaluate cenv env e1 bv /\
~ (bv = Bvalue (Lit (Bool F)))
==>
evaluate cenv env (Log Or e1 e2) bv)

/\

(! cenv env e1 e2 op n1 n2.
evaluate cenv env e1 (Bvalue (Lit (Num n1))) /\
evaluate cenv env e2 (Bvalue (Lit (Num n2)))
==>
evaluate cenv env (Op (Opn op) e1 e2) (Bvalue (Lit (Num (op n1 n2)))))

/\

(! cenv env e1 e2 op n1 n2.
evaluate cenv env e1 (Bvalue (Lit (Num n1))) /\
evaluate cenv env e2 (Bvalue (Lit (Num n2)))
==>
evaluate cenv env (Op (Opb op) e1 e2) (Bvalue (Lit (Bool (op n1 n2)))))

/\

(! cenv env e1 e2 op err.
evaluate cenv env e1 (Berror err)
==>
evaluate cenv env (Op op e1 e2) (Berror err))

/\

(! cenv env e1 e2 op v err.
evaluate cenv env e1 (Bvalue v) /\
evaluate cenv env e2 (Berror err)
==>
evaluate cenv env (Op op e1 e2) (Berror err))

/\

(! cenv env e1 e2 op v1 v2.
evaluate cenv env e1 (Bvalue v1) /\
evaluate cenv env e2 (Bvalue v2) /\
(~ (? n1. v1 = Lit (Num n1)) \/ ~ (? n2. v2 = Lit (Num n2)))
==>
evaluate cenv env (Op op e1 e2) (Berror F))

/\

(! cenv env e1 e2 e3 bv.
evaluate cenv env e1 (Bvalue (Lit (Bool T))) /\
evaluate cenv env e2 bv
==>
evaluate cenv env (If e1 e2 e3) bv)

/\

(! cenv env e1 e2 e3 bv.
evaluate cenv env e1 (Bvalue (Lit (Bool F))) /\
evaluate cenv env e3 bv
==>
evaluate cenv env (If e1 e2 e3) bv)

/\

(! cenv env e1 e2 e3 v.
evaluate cenv env e1 (Bvalue v) /\
(v <> Lit (Bool T) /\ v <> Lit (Bool F))
==>
evaluate cenv env (If e1 e2 e3) (Berror F))

/\

(! cenv env e1 e2 e3 err.
evaluate cenv env e1 (Berror err)
==>
evaluate cenv env (If e1 e2 e3) (Berror err))

/\

(! cenv env e pes v bv.
evaluate cenv env e (Bvalue v) /\
evaluate_match cenv env v pes bv
==>
evaluate cenv env (Mat e pes) bv)

/\

(! cenv env e pes err.
evaluate cenv env e (Berror err)
==>
evaluate cenv env (Mat e pes) (Berror err))

/\

(! cenv env n e1 e2 v bv.
evaluate cenv env e1 (Bvalue v) /\
evaluate cenv (bind n v env) e2 bv
==>
evaluate cenv env (Let n e1 e2) bv)

/\

(! cenv env n e1 e2 err.
evaluate cenv env e1 (Berror err)
==>
evaluate cenv env (Let n e1 e2) (Berror err))

/\

(! cenv env funs e bv.
evaluate cenv (build_rec_env funs env) e bv
==>
evaluate cenv env (Letrec funs e) bv)

/\

(! cenv env.
T
==>
evaluate_list cenv env [] (Bvalue []))

/\

(! cenv env e es v vs.
evaluate cenv env e (Bvalue v) /\
evaluate_list cenv env es (Bvalue vs)
==>
evaluate_list cenv env (e::es) (Bvalue (v::vs)))

/\

(! cenv env e es err.
evaluate cenv env e (Berror err)
==>
evaluate_list cenv env (e::es) (Berror err))

/\

(! cenv env e es v err.
evaluate cenv env e (Bvalue v) /\
evaluate_list cenv env es (Berror err)
==>
evaluate_list cenv env (e::es) (Berror err))

/\

(! cenv env v.
T
==>
evaluate_match cenv env v [] (Berror T))

/\

(! cenv env v p e pes env' bv.
(pmatch cenv p v env = Match env') /\
evaluate cenv env' e bv
==>
evaluate_match cenv env v ((p,e)::pes) bv)

/\

(! cenv env v p e pes bv.
(pmatch cenv p v env = No_match) /\
evaluate_match cenv env v pes bv
==>
evaluate_match cenv env v ((p,e)::pes) bv)

/\

(! cenv env v p e pes.
(pmatch cenv p v env = Match_type_error)
==>
evaluate_match cenv env v ((p,e)::pes) (Berror F))`;


(* TODO: declaration evaluation *)

(* ------------------------ Type system --------------------------------- *)

(* The type system does not currently support let polymorphism, but does 
* support polymorphic datatypes *)

(* constructor type environments: each constructor has a type 
 * forall (tyvarN list). t list -> typeN *)
val _ = type_abbrev( "tenvC" , ``: (conN, (tvarN list # t list # typeN)) env``); 
(* Type environments *)
val _ = type_abbrev( "tenvE" , ``: (varN, t) env``);

(* A pattern matches values of a certain type and extends the type environment
 * with the pattern's binders.  The pattern's type does not depend on the input
 * environment *)
(*val type_p : tenvC -> tenvE -> pat -> t -> tenvE -> bool*)

(* An expression has a type *)
(*val type_e : tenvC -> tenvE -> exp -> t -> bool*)

(* A list of expressions has a list of types *)
(*val type_es : tenvC -> tenvE -> exp list -> t list -> bool*)

(* A value environment has a corresponding type environment.  Since all of the
 * entries in the environment are values, and values have no free variables,
 * each entry in the environment can be typed in the empty environment (if at
 * all) *)
(*val type_env : tenvC -> envE -> tenvE -> bool*)

(* Type a mutually recursive bundle of functions.  Unlike pattern typing, the
 * resulting environment does not extend the input environment, but just
 * represents the functions *)
(*val type_funs : tenvC -> tenvE -> (varN * varN * exp) list -> tenvE -> bool*)

(* Check a declaration and update the top-level environments *)
(*val type_d : tenvC -> tenvE -> dec -> tenvC -> tenvE -> bool*)

(*val type_ds : tenvC -> tenvE -> dec list -> tenvC -> tenvE -> bool*)

val _ = Hol_reln `

(! cenv tenv n t.
T
==>
type_p cenv tenv (Pvar n) t (bind n t tenv))

/\

(! cenv tenv b.
T
==>
type_p cenv tenv (Plit (Bool b)) Tbool tenv)

/\

(! cenv tenv n.
T
==>
type_p cenv tenv (Plit (Num n)) Tnum tenv)

/\

(! cenv tenv cn ps ts tvs tn ts' tenv'.
(LENGTH ts' = LENGTH tvs) /\
type_ps cenv tenv ps (MAP (type_subst (ZIP ( tvs, ts'))) ts) tenv' /\
(lookup cn cenv = SOME (tvs, ts, tn))
==>
type_p cenv tenv (Pcon cn ps) (Tapp ts' tn) tenv')

/\

(! cenv tenv.
T
==>
type_ps cenv tenv [] [] tenv)

/\

(! cenv tenv p ps t ts tenv' tenv''.
type_p cenv tenv p t tenv' /\
type_ps cenv tenv' ps ts tenv''
==>
type_ps cenv tenv (p::ps) (t::ts) tenv'')`;

val _ = Hol_reln `

(! cenv tenv b.
T
==>
type_e cenv tenv (Val (Lit (Bool b))) Tbool)

/\
(! cenv tenv n.
T
==>
type_e cenv tenv (Val (Lit (Num n))) Tnum)

/\

(! cenv tenv cn vs tvs tn ts' ts.
(LENGTH tvs = LENGTH ts') /\
type_es cenv tenv (MAP Val vs) 
  (MAP (type_subst (ZIP ( tvs, ts'))) ts) /\
(lookup cn cenv = SOME (tvs, ts, tn))
==>
type_e cenv tenv (Val (Conv cn vs)) (Tapp ts' tn))

/\

(! cenv tenv env tenv' n e t1 t2.
type_env cenv env tenv' /\
type_e cenv (bind n t1 tenv') e t2
==>
type_e cenv tenv (Val (Closure env n e)) (Tfn t1 t2))

/\

(! cenv tenv env funs n t tenv' tenv''.
type_env cenv env tenv' /\
type_funs cenv (merge tenv'' tenv') funs tenv'' /\
(lookup n tenv'' = SOME t)
==>
type_e cenv tenv (Val (Recclosure env funs n)) t)

/\

(! cenv tenv cn es tvs tn ts' ts.
(LENGTH tvs = LENGTH ts') /\
type_es cenv tenv es (MAP (type_subst (ZIP ( tvs, ts'))) ts) /\
(lookup cn cenv = SOME (tvs, ts, tn))
==>
type_e cenv tenv (Con cn es) (Tapp ts' tn))

/\

(! cenv tenv n t.
(lookup n tenv = SOME t)
==>
type_e cenv tenv (Var n) t)

/\

(! cenv tenv n e t1 t2.
type_e cenv (bind n t1 tenv) e t2
==>
type_e cenv tenv (Fun n e) (Tfn t1 t2))

/\

(! cenv tenv e1 e2 t1 t2.
type_e cenv tenv e1 (Tfn t1 t2) /\
type_e cenv tenv e2 t1
==>
type_e cenv tenv (App e1 e2) t2)

/\

(! cenv tenv l e1 e2.
type_e cenv tenv e1 Tbool /\
type_e cenv tenv e2 Tbool
==>
type_e cenv tenv (Log l e1 e2) Tbool)

/\

(! cenv tenv op e1 e2.
type_e cenv tenv e1 Tnum /\
type_e cenv tenv e2 Tnum
==>
type_e cenv tenv (Op (Opn op) e1 e2) Tnum)

/\

(! cenv tenv op e1 e2.
type_e cenv tenv e1 Tnum /\
type_e cenv tenv e2 Tnum
==>
type_e cenv tenv (Op (Opb op) e1 e2) Tbool)

/\

(! cenv tenv e1 e2 e3 t.
type_e cenv tenv e1 Tbool /\
type_e cenv tenv e2 t /\
type_e cenv tenv e3 t
==>
type_e cenv tenv (If e1 e2 e3) t)

/\

(! cenv tenv e pes t1 t2.
type_e cenv tenv e t1 /\
(! ((p,e) :: LIST_TO_SET pes) tenv'.
   type_p cenv tenv p t1 tenv' /\
   type_e cenv tenv' e t2)
==>
type_e cenv tenv (Mat e pes) t2)

/\

(! cenv tenv n e1 e2 t1 t2.
type_e cenv tenv e1 t1 /\
type_e cenv (bind n t1 tenv) e2 t2
==>
type_e cenv tenv (Let n e1 e2) t2)

/\

(! cenv tenv funs e t tenv'.
type_funs cenv (merge tenv' tenv) funs tenv' /\
type_e cenv (merge tenv' tenv) e t
==>
type_e cenv tenv (Letrec funs e) t)

/\

(! cenv tenv.
T
==>
type_es cenv tenv [] [])

/\

(! cenv tenv e es t ts.
type_e cenv tenv e t /\
type_es cenv tenv es ts
==>
type_es cenv tenv (e::es) (t::ts))

/\

(! cenv.
T
==>
type_env cenv [] [])

/\

(! cenv n v env t tenv.
type_e cenv [] (Val v) t /\
type_env cenv env tenv
==>
type_env cenv (bind n v env) (bind n t tenv))

/\

(! cenv env.
T
==>
type_funs cenv env [] emp)

/\

(! cenv env fn n e funs env' t1 t2.
type_e cenv (bind n t1 env) e t2 /\
type_funs cenv env funs env' /\
(lookup fn env' = NONE)
==>
type_funs cenv env ((fn, n, e)::funs) (bind fn (Tfn t1 t2) env'))`;


val _ = Hol_reln `

(! cenv tenv p e t tenv'.
type_p cenv tenv p t tenv' /\
type_e cenv tenv e t
==>
type_d cenv tenv (Dlet p e) cenv tenv')

/\

(! cenv tenv funs tenv'.
type_funs cenv (merge tenv' tenv) funs tenv'
==>
type_d cenv tenv (Dletrec funs) cenv (merge tenv' tenv))

/\

(* TODO: typing declarations *)
(! cenv tenv tdecs.
F
==>
type_d cenv tenv (Dtype tdecs) cenv tenv)`;

val _ = Hol_reln `

(! cenv tenv.
T
==>
type_ds cenv tenv [] cenv tenv)

/\

(! cenv tenv d ds cenv' tenv' cenv'' tenv''.
type_d cenv tenv d cenv' tenv' /\
type_ds cenv' tenv' ds cenv'' tenv''
==>
type_ds cenv tenv (d::ds) cenv'' tenv'')`;

(* --------- Auxiliary definitions used in the type soundness proofs -------- *)

(* An evaluation context has the second type when its hole is filled with a
 * value of the first type. *)
(*val type_ctxt : tenvC -> tenvE -> ctxt -> t -> t -> bool*)
(*val type_ctxts : tenvC -> (ctxt*envE) list -> t -> t -> bool*)
(*val type_state : tenvC -> state -> t -> bool*)

val _ = Hol_reln `

(! cenv tenv e t1 t2.
type_e cenv tenv e t1
==>
type_ctxt cenv tenv (Capp1 () e) (Tfn t1 t2) t2)

/\

(! cenv tenv env n e t1 t2.
type_e cenv tenv (Val (Closure env n e)) (Tfn t1 t2)
==>
type_ctxt cenv tenv (Capp2 env n e ()) t1 t2)

/\

(! cenv tenv env funs n t1 t2 tenv' tenv''.
type_env cenv env tenv' /\
type_funs cenv (merge tenv'' tenv') funs tenv'' /\
(lookup n tenv'' = SOME (Tfn t1 t2)) 
==>
type_ctxt cenv tenv (Capp3 env funs n ()) t1 t2)

/\

(! cenv tenv op e.
type_e cenv tenv e Tbool
==>
type_ctxt cenv tenv (Clog op () e) Tbool Tbool)

/\

(! cenv tenv op e.
type_e cenv tenv e Tnum
==>
type_ctxt cenv tenv (Cop1 (Opn op) () e) Tnum Tnum)

/\

(! cenv tenv op e.
type_e cenv tenv e Tnum
==>
type_ctxt cenv tenv (Cop1 (Opb op) () e) Tnum Tbool)

/\

(! cenv tenv op v.
type_e cenv tenv (Val v) Tnum
==>
type_ctxt cenv tenv (Cop2 (Opn op) v ()) Tnum Tnum)

/\

(! cenv tenv op v.
type_e cenv tenv (Val v) Tnum
==>
type_ctxt cenv tenv (Cop2 (Opb op) v ()) Tnum Tbool)

/\

(! cenv tenv e1 e2 t.
type_e cenv tenv e1 t /\
type_e cenv tenv e2 t
==>
type_ctxt cenv tenv (Cif () e1 e2) Tbool t)

/\

(! cenv tenv t1 t2 pes.
(! ((p,e) :: LIST_TO_SET pes) tenv'.
   type_p cenv tenv p t1 tenv' /\
   type_e cenv tenv' e t2)
==>
type_ctxt cenv tenv (Cmat () pes) t1 t2)

/\

(! cenv tenv e t1 t2 n.
type_e cenv (bind n t1 tenv) e t2
==>
type_ctxt cenv tenv (Clet n () e) t1 t2)

/\

(! cenv tenv cn vs es ts1 ts2 t tn ts' tvs.
(LENGTH tvs = LENGTH ts') /\
type_es cenv tenv (REVERSE (MAP Val vs)) 
        (MAP (type_subst (ZIP ( tvs, ts'))) ts1) /\
type_es cenv tenv es (MAP (type_subst (ZIP ( tvs, ts'))) ts2) /\
(lookup cn cenv = SOME (tvs, ts1++([t]++ts2), tn))
==>
type_ctxt cenv tenv (Ccon cn vs () es) (type_subst (ZIP ( tvs, ts')) t) 
          (Tapp ts' tn))`;

val _ = Hol_reln `

(! tenvC t.
T
==>
type_ctxts tenvC [] t t)

/\

(! tenvC c env cs tenv t1 t2 t3.
type_env tenvC env tenv /\
type_ctxt tenvC tenv c t1 t2 /\
type_ctxts tenvC cs t2 t3
==>
type_ctxts tenvC ((c,env)::cs) t1 t3)`;

val _ = Hol_reln `

(! tenvC envC env e c t1 t2 tenv.
type_ctxts tenvC c t1 t2 /\
type_env tenvC env tenv /\
type_e tenvC tenv e t1
==>
type_state tenvC (envC, env, e, c) t2)`;

(* TODO: Typing d_states *)


(* ------ Auxiliary relations for proving Big/small step equivalence ------ *)

(*val evaluate_ctxt : envC -> envE -> ctxt -> v -> v big_step_result -> bool*)
(*val evaluate_ctxts : envC -> (ctxt*envE) list -> v -> v big_step_result -> bool*)
(*val evaluate_state : state -> v big_step_result -> bool*)

val _ = Hol_reln `

(! cenv env e env' n e' bv v.
evaluate cenv env e (Bvalue v) /\
evaluate cenv (bind n v env') e' bv
==>
evaluate_ctxt cenv env (Capp1 () e) (Closure env' n e') bv)

/\

(! cenv env e v bv e' funs fn n env'.
evaluate cenv env e (Bvalue v) /\
(find_recfun fn funs = SOME (n,e')) /\
evaluate cenv (bind n v (build_rec_env funs env')) e' bv
==>
evaluate_ctxt cenv env (Capp1 () e) (Recclosure env' funs fn) bv)

/\

(! cenv env e v l cn es.
((v = Lit l) \/ (v = Conv cn es))
==>
evaluate_ctxt cenv env (Capp1 () e) v (Berror F)) 

/\

(! cenv env e v env' funs fn n err e'.
((v = Closure env' n e') \/ (v = Recclosure env' funs fn)) /\
evaluate cenv env e (Berror err)
==>
evaluate_ctxt cenv env (Capp1 () e) v (Berror err)) 

/\

(! cenv env e v fn funs env'.
evaluate cenv env e (Bvalue v) /\
(find_recfun fn funs = NONE) 
==>
evaluate_ctxt cenv env (Capp1 () e) (Recclosure env' funs fn) (Berror F)) 

/\

(! cenv env env' n e v bv.
evaluate cenv (bind n v env') e bv
==>
evaluate_ctxt cenv env (Capp2 env' n e ()) v bv)

/\

(! cenv env env' funs fn v bv e' n.
(find_recfun fn funs = SOME (n,e')) /\
evaluate cenv (bind n v (build_rec_env funs env')) e' bv
==>
evaluate_ctxt cenv env (Capp3 env' funs fn ()) v bv)

/\

(! cenv env env' funs fn v.
(find_recfun fn funs = NONE)
==>
evaluate_ctxt cenv env (Capp3 env' funs fn ()) v (Berror F))

/\

(! cenv env op e v bv.
evaluate cenv env (Log op (Val v) e) bv
==>
evaluate_ctxt cenv env (Clog op () e) v bv)

/\

(! cenv env op e v bv.
evaluate cenv env (Op op (Val v) e) bv
==>
evaluate_ctxt cenv env (Cop1 op () e) v bv)

/\

(! cenv env op v1 v2 bv.
evaluate cenv env (Op op (Val v1) (Val v2)) bv
==>
evaluate_ctxt cenv env (Cop2 op v1 ()) v2 bv)

/\

(! cenv env e1 e2 v bv.
evaluate cenv env (If (Val v) e1 e2) bv
==>
evaluate_ctxt cenv env (Cif () e1 e2) v bv)

/\

(! cenv env pes v bv.
evaluate cenv env (Mat (Val v) pes) bv
==>
evaluate_ctxt cenv env (Cmat () pes) v bv)

/\

(! cenv env n e v bv.
evaluate cenv env (Let n (Val v) e) bv
==>
evaluate_ctxt cenv env (Clet n () e) v bv)

/\

(! cenv env n vs es v bv.
evaluate cenv env (Con n (MAP Val (REVERSE vs) ++ ([Val v] ++ es))) bv
==>
evaluate_ctxt cenv env (Ccon n vs () es) v bv)`;

val _ = Hol_reln `

(! cenv v.
T
==>
evaluate_ctxts cenv [] v (Bvalue v))

/\

(! cenv c cs env v v' bv.
evaluate_ctxt cenv env c v (Bvalue v') /\
evaluate_ctxts cenv cs v' bv 
==>
evaluate_ctxts cenv ((c,env)::cs) v bv)

/\

(! cenv c cs v env err.
evaluate_ctxt cenv env c v (Berror err)
==>
evaluate_ctxts cenv ((c,env)::cs) v (Berror err))`;

val _ = Hol_reln `

(! cenv env e c v bv.
evaluate cenv env e (Bvalue v) /\
evaluate_ctxts cenv c v bv
==>
evaluate_state (cenv, env, e, c) bv)

/\

(! cenv env e c err.
evaluate cenv env e (Berror err)
==>
evaluate_state (cenv, env, e, c) (Berror err))`;
val _ = export_theory()

